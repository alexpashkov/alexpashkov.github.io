<html>
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Alex's Pashkov Teach Yourself Computer Science Daily Blog</title>
    <style>
      main {
        max-width: 1000px;
        margin: 0 auto;
      }

      .references {
        font-size: 12px;
      }
      table,
      th,
      td {
        border: 1px solid gray;
        border-collapse: collapse;
      }
      th,
      td {
        padding: 10px;
      }
    </style>
  </head>
  <body>
    <main>
      <h1>Alex's Pashkov Teach Yourself Computer Science Daily Blog</h1>
      <p>
        I am committing to a daily routine going through subjects and materials
        from
        <a href="https://teachyourselfcs.com/">teachyourselfcs.com</a>. The
        subjects are:
      </p>
      <ol>
        <li>Programming</li>
        <li>Computer Architecture</li>
        <li>Algorithms and Data Structures</li>
        <li>Math for CS</li>
        <li>Operating Systems</li>
        <li>Computer Networking</li>
        <li>Databases</li>
        <li>Languages and Compilers</li>
        <li>Distributed Systems</li>
      </ol>
      <p>
        Given there are nine of them, an expectation to spend 100-200 hours on
        each and that I'm studying up to an hour daily, it should take up to 5
        years to finish. That is a long-term investment that is supposed to help
        me excel in the profession. Let's see how long I last.
      </p>
      <p>
        Below you can see short daily notes on what I've learned. You can find
        commit history
        <a
          href="https://github.com/alexpashkov/alexpashkov.github.io/commits/teachyourselfcs"
          >here</a
        >
        to make sure I am not cheating.
      </p>
      <table>
        <tr>
          <th>Date</th>
          <th>Subject</th>
          <th>Material</th>
          <th>Note</th>
        </tr>
        <tr>
          <td>August 31th, 2020</td>
          <td>Programming</td>
          <td>
            <a
              href="https://www.youtube.com/watch?v=8LIZqnf7gIs&list=PLhMnuBfGeCDNgVzLPxF9o5UNKG1b-LFY9&index=10&t=893s"
              >Video of Lecture 9 from Structure and Interpretation of Computer
              Programs, Berkeley 61a</a
            >
          </td>
          <td>
            <p>
              Abstract data types are entities that provide a set of actions on
              it and encapsulate implementation detail. The user of the data
              type only needs to know the interface of it to use it. Abstract
              data types are used as building block in the program. We can
              compose simpler data-types into more complicated ones, thus
              defining new levels of abstraction.
            </p>
            <p>
              The idea is very powerful: take something simple and build a more
              complicated thing from it, hide implementation, repeat the process
              using new functionality until you have what you need.
            </p>
            <p>
              The most basic data type is a pair. In Lisp<sup>1</sup> it's a
              building block for more complicated data-types. A pair can be
              implemented using first-class functions. So, if the language has
              that, you can potentially build anything.
            </p>
            <ol class="references">
              <li id="clojure">
                Scheme, probably. Clojure, apparently, is built using Java
                data-types
              </li>
            </ol>
          </td>
        </tr>
        <tr>
          <td>August 30th, 2020</td>
          <td>Computer Architecture</td>
          <td>
            <i
              >Beginning of the Chapter 3, Machine-Level Representation of
              Programs</i
            >, Computer Systems: A Programmer's Perspective, 3/E, by Randal E.
            Bryant and David R. O'Hallaron, Carnegie Mellon University
          </td>
          <td>
            <p>
              Processors work with strings of bytes that represent machine level
              instructions. It's important to understand machine level
              representations of code since some situations like improving
              performance in the critical sections of the program may require
              peeking into compiler- generated machine-level. Understanding the
              machine-level code requires working with it, e.g doing the
              exercises from the book.
            </p>
            <p>
              Instruction set (also referred as Instruction Set Architecture or
              ISA) is an abstract model of a computer, a realization ISA, such
              as CPU is an implementation
              <sup><a href="#instruction_set">1</a></sup
              >. The most common architecture nowadays is Intel's x86-64 which
              has 64 bit address space and allows enormous amounts of memory (up
              to 2<sup>64</sup>), as opposed to 32 bit ISA's that allow only
              around 4GB.
            </p>
            <ol class="references">
              <li id="instruction_set">
                Instruction set architecture,
                <a
                  href="https://en.wikipedia.org/wiki/Instruction_set_architecture"
                  >https://en.wikipedia.org/wiki/Instruction_set_architecture</a
                >
              </li>
            </ol>
          </td>
        </tr>
      </table>
    </main>
  </body>
</html>
